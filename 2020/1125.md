```HTML

```

# 算法——树、二叉搜索树

这一章的树节点图用md很难画出来啊！！！

### 树

一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点以及另个或多个子节点。

​																11

​											7											15

​								5					9					13						20

​						3			6		8		10		12		14			18		25

位于树顶部的节点叫做根节点。

树中的每个元素都叫节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点，没有子元素的节点称为外部节点或叶节点。

字树：由节点和它的后代构成，eg：上图的节点13、12、14构成了树中 的一棵子树。

深度：节点的一个属性。节点的深度取决于它祖先节点的数量。eg: 节点3有三个祖先节点（5、7、11），其深度为3。

高度：树的属性，取决于所有节点深度的最大值，上图中树的高度为3

键：键是树相关的术语中对节点的称呼

### 二叉搜索树

二叉树中的节点最多只能有2个子节点：一个左侧子节点，一个右侧子节点

二叉搜索树（BST）是二叉树的一种，但是它只允许在左侧节点存储比父节点小的值，在右侧存储比父节点大或等于的值

实现二叉搜索树（运用递归）

```HTML
function BinarySearchTree() {
	var Node = function(key) {
		this.key = key;
		this.left = null;
		this.right = null;
	};
	var root = null;
	// 引入辅助函数
	var insertNode = function(node, newNode) {
		if (newNode.key < node.key) {
			if (node.left === null) {
				node.left = newNode;
			}
			else {
				insertNode(node.left, newNode);    
			}
		}
		else {
			if (node.right === null) {
				node.right = newNode;
			}
			else {
				insertNode(node.right, newNode);    
			}
		}
	}
	// 向树中插入一个键
	this.insert = function() {
		var newNode = new Node(key);
		if (root === null) {
			root = newNode;
		}
		else {
			insertNode(root, newNode);
		}
	};
}
```

### 遍历树的三种方法

遍历一棵树指访问树的每个节点并对它们进行某种操作的过程。

1、中序遍历

中序遍历是一种以上行顺序访问BST所有节点的遍历方式，即以从最小到最大的顺序访问所有节点。

顺序：先访问左侧子节点，然后访问节点自身，最后是右侧子节点

中序遍历的一种应用是对树进行排序操作

实现（接上BST的实现方法）

```HTML
function BinarySearchTree() {
	// 辅助类函数
	var inOrderTraverseNode = function(node, callback) {
		if (node !== null) {
			inOrderTraverseNode(node.left, callback);
			callback(node.key);
			inOrderTraverseNode(node.right, callback);
		}
	}
	// 中序遍历
	this.inOrderTraverse = function(callback) {
		inOrderTraverseNode(root, callback);
	};
};
// 浏览器上输出树的各个键
function printNode(value) {
	console.log(value);
};
BinarySearchTree(printNode);
// 章首的树将输出：
//	3	5	6	7	8	9	10	11	12	13	14	15	18	20	25
```

2、先序遍历

先序遍历是以优先于后代节点的顺序访问每个节点。

顺序：先访问节点自身，然后访问左侧子节点，最后是右侧子节点

先序遍历的一种应用是打印一个结构化的文档

实现（接上BST的实现方法）

```HTML
function BinarySearchTree() {
	// 辅助类函数
	var preOrderTraverseNode = function(node, callback) {
		if (node !== null) {
			callback(node.key);
			preOrderTraverseNode(node.left, callback);
			preOrderTraverseNode(node.right, callback);
		}
	};
	// 先序遍历
	this.preOrderTraverse = function(callback) {
		preOrderTraverseNode(root, callback);
	};
};
BinarySearchTree(printNode);
// 章首的树将输出：
//	11	7	5	3	6	9	8	10	15	13	12	14	20	18	25
```

3、后序遍历

后序遍历是先访问节点的后代节点，在访问节点本身。

顺序：先访问访问左侧子节点，然后右侧子节点，最后是节点本身

后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小

实现（接上BST的实现方法）

```HTML
function BinarySearchTree() {
	// 辅助类函数
	var postOrderTraverseNode = function(node, callback) {
		if (node !== null) {
			postOrderTraverseNode(node.left, callback);
			postOrderTraverseNode(node.right, callback);
			callback(node.key);
		}
	};
	// 后序遍历
	this.postOrderTraverse = function(callback) {
		postOrderTraverseNode(root, callback);
	};
};
BinarySearchTree(printNode);
// 章首的树将输出：
//	3	6	5	8	10	9	7	12	14	13	18	25	20	15	11
```