# 算法——排序算法

树结构中的自平衡树和图结构略复杂，看了下书中对应的章节没有看懂，故先跳过，后期如若有必要再补充

首先创建一个数组来表示待排序的数据结构

```HTML
function ArrayList() {
	var arr = [];
	// 添加元素
	this.insert = function(item) {
		arr.push(item);
	};
	// 拼接数组元素为一字符串
	this.toString = function() {
		return arr.join();
	};
};
```

### 冒泡排序

比较任意两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，似气泡升至表面，故名冒泡

时间复杂度：O(n^2)

实现（接头部的类）

```HTML
this.bubbleSort = function() {
	let length = arr.length;
	for (let i = 0;i < length;i++) {
		// 每走完一轮i循环，都有一个本轮循环中的最大值被固定在右侧，故每走完一轮循环，下轮循环需比较的值都-1，所以j的循环要-i
		for (let j = 0;j < length - 1 - i;j++) {
			if (arr[j] > arr[j + 1]) {
				// 交换第j项和第j + 1项
				swap(arr, j, j + 1);
			}
		}
	}
};
// 辅助函数
var swap = function(arr, index1, index2) {
	// 设置中间值
	let aux = arr[index1];
	arr[index1] = arr[index2];
	arr[index2] = aux;
	// 用ES6解构赋值更简单
	// [arr[index1], arr[index2]] = [arr[index2], arr[index1]];
};
```

### 选择排序

找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推

时间复杂度：O(n^2)

实现（接头部的类）

```HTML
this.selectionSort = function() {
	let length = arr.length, indexMin;
	// 循环数组，因每次都将最小值放在前边，到最后一位时，无需循环
	for (let i = 0;i < length - 1;i++) {
		// 此赋值操作为下indexMin !== i判断做准备，每循环一次给indexMin重新赋值
		indexMin = i;
		// 此轮循环为最小值和所有值做对比，故需对比到最后一位
		for (let j = i;j < length;j++) {
			if (arr[indexMin] > arr[j]) {
				indexMin = j;
			}
		}
		// indexMin !== i时，说明当前第i项不是该轮循环最小项，需和最小项交换值
		if (indexMin !== i) {
			swap(arr, indexMin, i);
		}
	}
};
```

### 插入排序

插入排序从第二项开始，后边到每一项都与前边项组成的数组的做对比，插入在应该插入的位置，以此方式构建最后的排序数组

时间复杂度：

实现（接头部的类）

```HTML
this.insertionSort = function() {
	let length = arr.length, j, temp;
	for (let i = 1;i > length;i++) {
		j = i;
		temp = arr[i];
		while (j > 0 && arr[j - 1] > arr[j]) {
			// 前一项比后一项大，前一项移到后一项位置
			arr[j] = arr[j - 1];
			j --;
		}
		// 待排序的项，前边项没有比其大时，插入到当前位置
		arr[j] = temp;
	}
}
```

### 归并排序

将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并为较大的数组，直到最后只有一个排序完毕的大数组

时间复杂度：O(nlog n)

实现（接头部的类）

```HTML
this.mergeSort = function() {
	arr = mergeSortRec(arr);
};
// 辅助函数
var mergeSortRec = function(arr) {
	let length = arr.length;
	if (length === 1) {
		return arr;
	}
	let mid = Matn.floor(length / 2),
	left = arr.slice(0, mid),
	right = arr.slice(mid, length);
	return merge(mergeSortRec(left), mergeSortRec(right));
};
// 辅助函数
var merge = function(left, right) {
	let result = [],
	il = 0,
	ir = 0;
	while (il < left.length && ir < right.length) {
		if (left[il] > right[ir]) {
			result.push(right[ir]);
			ir ++;
		}
		else {
			result.push(left[il]);
			il ++;
		}
	}
	while (il < left.length) {
		result.push(left[il]);
		il ++;
	}
	while (ir < right.length) {
		result.push(right[ir]);
		ir ++;
	}
	return result;
}

```