# 2020-09-17百度面试题

### 一面

##### 盒模型

```HTML
	W3C标准盒模型：	width、height = content
	IE盒模型：	width、height = content + padding + border
```

##### block和inline-block、inline区别

```html
	block
		1、block独占一行，多个block元素会各自新起一行。不设置宽度默认撑满父级宽度
		2、可设置width、height，即使设置宽度，仍然独占一行
		3、可设置margin、padding
	inline
		1、不独占一行，多个相邻inline元素会排列在同一行，一行排不下才换行，宽度由内容决定
		2、设置width、height无效
		3、水平方向的margin、padding有效，竖直方向的margin、padding无效
	inline-block
		1、不独占一行，可设置width、height，默认宽度由内容决定，可设置margin、padding
```

##### position有哪些？区别

```HTML
	relative：相对定位，相对于正常的位置进行定位
	absolute：绝对定位，若父级设置position:relative，则相对父级定位，否则相对于document定位
	fixed：固定定位，相对于浏览器可视区域定位
```

##### 为什么要初始化CSS样式

```HTML
	因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，未初始化CSS样式会出现不同浏览器之间的页面显示差异
```

##### flex

```HTML
	父类
	flex-direction： 主轴方向
					row: 默认值，左到右
					row-reverse: 右到左
					column:	上到下
					column-reverse: 下到上
	flex-wrap:	换行
					nowrap: 默认值，不换行
					wrap: 换行，第一行在上方
					wrap-reverse: 换行，第一行在下方
					
	flex-flow: 以上两个属性的简写形式，默认row、nowrap
	
	justify-content:  主轴方向上的对齐方式
					flex-start: 默认值，左对齐
					flex-end: 右对齐
					center: 居中
					space-between: 两端对齐，项目之间间隔相等
					space-around: 每个项目两侧的间隔相等，项目之间的间隔比项目与边框的间隔大一倍
					
	align-items：交叉轴方向上的对齐方式
					flex-start: 交叉轴的起点对齐
					flex-end: 交叉轴的终点对齐
					center: 交叉轴的居中
					baseline: 项目的第一行文字的基线对齐
					stretch: 默认值，如果父级未设置高度或设为auto，将占满整个容器的高度
					
	align-content: 多根轴线的对齐方式，，只有一根轴线该属性不起作用
					flex-start: 与交叉轴的起点对齐
					flex-end: 与交叉轴的终点对齐
					center: 与交叉轴的中点对齐
					space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布。
					space-around: 每根轴线两侧的间隔都相等。故轴线之间的间隔比轴线与边框的间隔大一倍。
					stretch: 默认值，轴线占满整个交叉轴。
	子类
	order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0
	
	flex-grow: 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
				如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
				
	flex-shrink: 定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
				如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
				负值对该属性无效
				
	flex-basis: 定义了再分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认auto，即项目的本来大小
				可设置为与width、height属性一样的值（eg：200px）则项目将占据固定空间
				
	flex: flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
			该属性有两个快捷值，auto（1 1 auto）和none（0 0 auto）
			
	align-self: 允许单个项目有与其他属性不一样的对齐方式，可覆盖align-items属性。默认值auto表示继承父级的align-items属性，若没有父级，则等同于stretch
				值有6种，除了auto，其他5种为与align-items属性完全一致
```

##### 如何竖直居中一个元素

```HTML
	1、
		.container {
			display: table;
		}
		.content {
			display: table-cell;
			vertical-align: middle;
		}
	2、
		.container {
			display: flex;
			align-items: center;
		}
	3、
		.container {
			position: relative;
		}
		.content {
			position: absolute;
			top: 0;
			bottom: 0;
			margin: auto;
		}
	4、
		.content{
			position: absolute;
			top: 50%;
			margin-top: -height/2;
		}
	5、
		.content {
			position: absolute;
			top: 50%;
			transform: translate(-50%,-50%);
		}
	6、
		.container {
			line-height: height;
		}
```

##### 用过哪些伪类和伪元素

```HTML
	伪元素：
		在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成，它们只在外部显示可见，但不会在文档的源代码中找到他们，因此称为伪元素
		eg:
			p::before{content:"第一章:";}
			p::first-line {background:red;}
	伪类：
		将特殊的效果添加到特定的选择器上，它是已有元素上添加类别的，不会产生新元素
		eg:
			a:hover {color: #FF00FF}
			p:first-child {color: red}
	区别：
		伪类表示状态
		伪元素表示真的有元素
		前者单冒号，后者双冒号
	伪类：
		:diabled		选择禁用的表单元素
		:checked		选择被选中的表单元素
		:after			在元素内部最前添加内容
		:before			在元素内部最后添加内容
		:nth-child(n)	匹配父元素下指定子元素，在所有子元素中排序第n
		:first-child	匹配第一个元素
```

##### viewport

```HTML
	<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
	// width:	设置viewport宽度，是一个正整数，或字符串"device-width"
	// device-width:	设备宽度
	// height:	设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置
	// initial-scale:	默认缩放比例(初始缩放比例)，数字，可以带小数
	// minimum-scale:	允许用户最小缩放比例，数字，可以带小数
	// maximum-scale:	允许用户最大缩放比例，数字，可以带小数
	// user-scalable:	是否允许手动缩放

延伸提问：怎么处理移动端1px被渲染成2px问题
	1、局部处理
		meta标签中的viewport属性，initial-scale设置为1
		rem按照设计稿标准走，外加利用transform的scale(0.5)缩小一倍即可
	2、全局处理
		meta标签中的viewport属性，initial-scale设置为0.5
		rem按照设计稿标准走
```

##### hack

```HTML
	原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式
	常见hack:
		属性hack
		选择器hack
		IE条件注释
```

##### content

```HTML
	CSS的content属性专门应用在before/after伪元素上，用于插入生成内容。最常见的应用是利用伪类来清除浮动
	// 利用伪类清除浮动
	.clearfix:after {
		content: ".";
		display: block;
		height: 0;
		visibility: hidden;
		clear: both;
	}
	.clear {
		*zoom: 1;
	}
	// 多行文字溢出省略
	p {
		position: relative;
		line-height: 1.5em;
		/* 高度为需要显示的行数*行高，比如这里我们显示两行，则为3 */
		height: 3em;
		/* 允许长单词换行到下一行 */
		word-wrap: break-word;
		over-flow: hidden;
	}
	p:after {
		content: "...";
		position: absolute;
		bottom: 0;
		right: 0;
		padding: 0 5px;
		background-color: #fff;
	}
```

##### rgba()和opacity的透明效果的不同

```HTML
	rgba前三个值表示颜色的red,green,blue值，最后一个表示alpha值，就是透明度值，不透明为1，只作于用元素的颜色或其背景色，无穿透效果
	opacity作用于元素，以及元素内的所有内容的透明度，，子元素会继承透明效果
```

##### CSS3创造一个纯三角形

```HTML
	/* 把上、左、右三条边隐藏掉（颜色设为 transparent） */
	#demo {
		width: 0;
		height: 0;
		border-width: 20px;
		border-style: solid;
		border-color: transparent transparent red transparent;
	}
```

##### js的数据类型

		6种基本数据类型
			undefined、null、string、number、boolean、symbol
		一种引用类型
			Object
		两种类型的区别：
			存储位置不同。
			基本数据类型是直接存储在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据
			引用数据类型是存储在堆中的对象，占据空间大，大小不固定。如果存储在栈中，会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
##### 数据类型判断方法？

```HTML
1、typeof
	typeof	[]				-->		object
	typeof	undefined		-->		undefined
	typeof	null			-->		object
	typeof	function(){}	-->		function
	缺点：
		不能判断null(原因是不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都在0的话会被判定为object类型，null的二进制表示全是0，所以执行typeof时返回"object")
2、instanceof
	用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，即判断对象是否是某一数据类型的实例
	2		instanceof		Number		-->		false
	[]		instanceof		Array		-->		true
	null	instanceof		Object		-->		false
	缺点：
		不能判断基本数据类型
3、Object.prototype.toString.call()
	'[object Number]'		'[object Null]'		'[object Undefined]'		'[object Array]'		'[object Function]'		'[object Date]'		
```

##### 冒泡、捕获。怎么阻止冒泡？

```HTML
W3C标准的DOM2级事件流向分为三个阶段：捕获阶段，目标阶段，冒泡阶段。

捕获阶段是指事件响应从最外层的Window开始，逐级向内层前进，直到具体事件目标元素。在捕获阶段，不会处理响应元素注册的冒泡事件。
目标阶段指触发事件的最底层的元素。
冒泡阶段与捕获阶段相反，事件的响应是从最底层开始一层一层往外传递到最外层的Window。

element.addEventListener(type, listener, useCapture)
	type
		监听事件类型的字符串
	listener
		事件监听回调函数，即事件触发后要处理的函数
	useCapture
		默认值false，表示事件冒泡；设为true时，表示事件捕获

事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素。
	1、节省内存占用，减少事件注册
	2、新增子对象时无需再次对其绑定事件，适合动态添加元素

阻止冒泡
	1、event.stopPropagation()
	2、e.cancelBubble=true;（IE）
阻止事件默认行为（不只冒泡）
	1、event.preventDefault()
	2、return false（IE）
```

##### 防抖节流

```html
防抖
	指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
节流
	指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
具体手写实现参照0903.md
```

##### 深浅拷贝

```HTML
浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间
深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。

浅拷贝：
	1、Object.assign()
			用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象
	2、Array.prototype.slice()
			slice方法返回一个由begin和end（不含）决定的原数组的浅拷贝，原数组不变
	3、Array.prototype.concat()
			concat方法返回一个由当前数组和其他若干数组或若干非数组值组成的新数组，浅拷贝
	4、扩展运算符...
深拷贝
	1、JSON.parse(JSON.stringify(obj))
			缺点：忽略undefined、function、symbol
	2、递归
		参照0906.md
```

##### call、apply、bind

```HTML
相同点：
	都是改变this指向
不同点：
	call、bind接收的执行函数fn形参为多个值，apply为一个数组
	call、apply会立即执行函数fn，bind不会立即执行，会返回一个函数

手写实现参照0902.md
```

##### 前端存储。用过indexDB么？

```HTML

```

##### 跨域解决方法

```HTML

```

##### 箭头函数和普通函数区别

```HTML

```

##### Promise

```HTML

```

##### async、await

```HTML

```

##### Set、Map

```HTML

```

##### Vue生命周期

```HTML

```

##### 组件传值哪些方式？

```HTML

```

##### Vuex

```HTML

```

##### 用过插槽么？

```HTML

```

##### 路由有什么模式？

```HTML

```

##### 怎么实现的权限控制

```HTML

```

##### nextTick用过么？

```HTML

```

##### computed、watch

```HTML

```

##### 虚拟DOM

```HTML

```

##### Vue3.0

```HTML

```

##### 项目IE9怎么做的兼容

```HTML

```

##### CDN了解么？

```HTML

```



### 二面

##### flex实现左边定宽，右边自适应

```HTML
	.container {
		width: 100%;
		height: 500px;
		background-color: yellow;
		display: flex;
	}
	.left {
		width: 200px;
		height: 200px;
		background-color: pink;
	}
	.right {
		height: 200px;
		background-color: red;
		/*定义项目的放大比例*/
		flex: 1;
	}

```

##### 路由怎么设置动态？

```HTML

```

##### 做的那些性能优化？除了代码层面还有哪些？

```HTML

```

##### 页面输入url的过程？到渲染方面可以做哪些优化？

```HTML

```

##### 不考虑webpack打包，单页面应用页面初次加载比较慢怎么办？

```HTML

```

### 三面

```HTML
介绍一下做的比较好的项目的业务流程
```

```HTML
				| L |

		| L |	| E |	| L |

| L |	| E |	| V |	| E |	| L |

		| L |	| E |	| L |

				| L |
1 * 2 * 1 * 4 * 3 * 4 + 1 * 1 * 4 * 3 * 4 = 144
问题：
	LEVEL的组合共有多少种？思路
	
注意：	1、只能相邻拼，不能交叉
	  2、可以折返，正序反序算两种

我的思路：
	开始位置分为两种，第一种凸出来的L，第二种凹进去的L，逐个分析
	第一种凸L，以顶部L为例：
		往下是E，E左右不符合，只能向下到V，V的情况有4种（第一次忘记可以折返的情形，计算的V情况3种，失误），4种类似，分析一种即可，以向左为例，到左边的E，左边E对应3个L，所以顶部总组合是 3 * 4 = 12，则凸出来的L的总组合是12 * 4 = 48；
	第二种凹L，以左上角L为例：
		左上角L有两种选择，向右或者向下（第一次忘记考虑了向右或向下两种情况，但是计算时忘记乘2，失误），两种情形一致，以向右E为例： 右边的E只能向下到V，V后的分析和顶部到V的情况一致：3 * 4 = 12，故两种情况是12 * 2 = 24，即左上角的总组合是24，凹进去的L总组合是24 * 4 = 96
	故总的LEVEL组合共48 + 96 = 144

面试官思路：
	凸出来的L有1种选择，E有1种选择，V有4种选择，V后的E有3种选择，故凸出来的L总组合：1 * 1 * 4 * 3 * 4 = 48
	凹进去的L有2种选择，E有1种选择，V有4种，E有3种，故凹进去的L总组合：2 * 1 * 4 * 3 * 4 = 96
	总组合：48 + 96 = 144
```